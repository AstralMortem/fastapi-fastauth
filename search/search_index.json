{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAuth","text":"<p> Ready-to-use customizable solution for FastAPI with Authentication, Authorization(RBAC) and OAuth2 support </p>"},{"location":"#about","title":"About","text":"<p>Here\u2019s a ready-to-use, customizable solution for FastAPI with Authentication, Authorization (RBAC), and OAuth2 support. This solution provides token based authentication(JWTHelper, Redis, DB), role-based access control, and OAuth2 integration. Highly inspired by FastAPI Users and AuthX:</p> <ul> <li>Documentation: https://astralmortem.github.io/fastapi-fastauth/</li> <li>Source Code: https://github.com/AstralMortem/fastapi-fastauth</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li> Authentication Support:<ul> <li> Access and Refresh Token Dependencies</li> <li> Different Token Strategy(JWTHelper, Redis, Session)</li> <li> Different Token locations(Header, Cookie, Query, etc.)</li> </ul> </li> <li> Authorization Support:<ul> <li> \"Role and Permission required\" Dependency</li> <li> OAuth2 support</li> </ul> </li> <li> User Management:<ul> <li> User Model protocol</li> <li> Service-Repository pattern for flexible customization</li> <li> Popular ORM support:<ul> <li> SQLAlchemy2.0 support</li> <li> Beanie</li> <li> Tortoise ORM</li> </ul> </li> </ul> </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>First you need to choose orm provider, for this examples we will use SQLAlchemy, and init <code>FastAuthSettings</code> class. Let`s init configuration, which we use later.</p> <pre><code>from fastauth.settings import FastAuthSettings\n\nsettings = FastAuthSettings()\n</code></pre> <p>There we can share some variables across classes inside library. Also we can extend or override config variables, for example by direct change, or inherit class.</p> <pre><code>from fastauth.settings import FastAuthSettings\n\nclass Settings(FastAuthSettings):\n    # Override flag to allow inactive users to login\n    ALLOW_INACTIVE_USERS: bool = False \n</code></pre>"},{"location":"configuration/#models","title":"Models","text":"<p>First of all, we need to create tables inside DB, so let`s implement ORM Models class. FastAuth support sqlalchemy out-the-box, so we just need to inherit ready to use mixins</p> <pre><code>from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\nfrom fastauth.contrib.sqlalchemy import BaseUUIDUserModel\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(BaseUUIDUserModel, Base):\n    pass\n</code></pre> <p>Another ID field</p> <p>You can customize User ID field, you need to inherit <code>BaseUserModel[ID]</code> class, and set <code>id</code> field <pre><code>from fastauth.contrib.sqlalchemy import BaseUserModel\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass User(BaseUserModel[int]):\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n</code></pre></p> <p>Now we have <code>User</code> model. But if you want add support of RBAC, you need to create <code>Role</code> and <code>Permission</code> models. <pre><code>from fastauth.contrib.sqlalchemy import BaseIntRoleModel, BaseIntPermissionModel, BaseRolePermissionRel\n\nclass Permission(BaseIntPermissionModel, Base):\n    pass\n\n\nclass Role(BaseIntRoleModel[Permission], Base):\n    permisions: Mapped[Permission] = relationship(lazy='selectin')\n\n\n# Need for sqlalchemy, to indentify many-to-many table\nclass RolePermissionRel(BaseRolePermissionRel[int, int], Base):\n    pass\n</code></pre></p> <p>Then we need to upgrade our <code>User</code> model and add connection between roles and users tables <pre><code>from fastauth.contrib.sqlalchemy import BaseUUIDUserModel, RBACMixin, BaseUserRoleRel\nimport uuid\n\nclass User(BaseUUIDUserModel,RBACMixin[Role], Base):\n    roles: Mapped[Role] = relationship(lazy=\"selectin\")\n\n\n# Need for sqlalchemy, to indentify many-to-many table\nclass UserRoleRel(BaseUserRoleRel[uuid.UUID, int], Base):\n    pass\n</code></pre></p> <p>Role and Permission ID field</p> <p>As for <code>User</code> model, you can also customize <code>Role</code> and <code>Permission</code> id field, by inherit <code>BaseRoleModel</code> and <code>BasePermissionModel</code>.</p> <pre><code>from fastauth.contrib.sqlalchemy import BaseRoleModel, BasePermissionModel\nfrom sqlalchemy.orm import Mapped, mapped_column\nimport uuid\n\nclass Role(BaseRoleModel[uuid.UUID]):\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, autoincrement=True, default=uuid.uuid4)\n\nclass Permission(BasePermissionModel[uuid.UUID]):\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, autoincrement=True, default=uuid.uuid4)\n</code></pre> <p>For OAuth support, we need create proper model too. <pre><code>from fastauth.contrib.sqlalchemy import BaseUUIDOAuthAccount\n\nclass OAuthAccount(BaseUUIDOAuthAccount):\n    pass\n</code></pre></p> <p>OAuth ID Field</p> <p>There is we can customize ID field to, just inherit <code>BaseOAuthModel</code> class</p> <p>After, we need to update <code>User</code> Model, and add proper lazy select for field</p> <pre><code>from fastauth.contrib.sqlalchemy import BaseUUIDUserModel, RBACMixin, OAuthMixin\nimport uuid\n\nclass User(BaseUUIDUserModel,RBACMixin[Role], OAuthMixin[OAuthAccount], Base):\n    roles: Mapped[Role] = relationship(lazy=\"selectin\")\n    oauth_accounts: Mapped[OAuthAccount] = relationship(lazy=\"joined\")\n</code></pre>"},{"location":"configuration/#repositories","title":"Repositories","text":"<p>To make the library as extensible as possible, we chose the Service-Repository architecture. So we need to implement repository class for every ORM Model.</p> <pre><code>from fastauth.repositories import IRoleRepository, IUserRepository, IOAuthRepository\nfrom fastauth.contrib.sqlalchemy import (\n    SQLAlchemyUserRepository,\n    SQLAlchemyOAuthRepository,\n    SQLAlchemyRoleRepository,\n)\nimport uuid\n\n\n\nclass UserRepository(SQLAlchemyUserRepository[User, uuid.UUID]):\n    model = User\n\n\nclass RoleRepository(SQLAlchemyRoleRepository[Role, int]):\n    model = Role\n\n\nclass OAuthRepository(SQLAlchemyOAuthRepository[OAuthAccount, uuid.UUID, User]):\n    model = OAuthAccount\n    user_model = User\n</code></pre> <p>Inside this classes we can override methods to get items from DB. After creation repos, we need to create dependencies, by using FastAPI Depends function, this is very simple.</p> <pre><code>from fastapi import Depends\nfrom typing import Annotated\n\nasync def get_user_repository(session: SessionDep):\n    return UserRepository(session)\n\n\nasync def get_oauth_repository(session: SessionDep):\n    return OAuthRepository(session)\n\n\nasync def get_role_repository(session: SessionDep):\n    return RoleRepository(session)\n\n\nUserRepoDep = Annotated[IUserRepository, Depends(get_user_repository)]\nOAuthRepoDep = Annotated[IOAuthRepository, Depends(get_oauth_repository)]\nRoleRepoDep = Annotated[IRoleRepository, Depends(get_role_repository)]\n</code></pre> <p>SessionDep</p> <p><code>SessionDep</code> is just annotation for sqlalchemy async session generator <pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\n\nengine = create_async_engine(\"&lt;DATABASE_URL&gt;\", echo=True)\nsession_factory = async_sessionmaker(engine, expire_on_commit=False)\n\n\nasync def get_session():\n    async with session_factory() as session:\n        try:\n            yield session\n        except Exception as e:\n            await session.rollback()\n            raise e\n        finally:\n            await session.close()\n\n\nSessionDep = Annotated[AsyncSession, Depends(get_session)]\n</code></pre></p>"},{"location":"configuration/#token-storage","title":"Token Storage","text":"<p>For user authentication, we need to use tokens. Tokens should be stored somewhere or have a mechanism for verifying authenticity. For this features we use <code>BaseTokenStorage</code> class, which handle how and where store tokens. The most simple token storage is jwt, because we do not need to use DB or Redis to store it physicaly. To work with JWT we need to make dependencies with <code>JWTTokenStorage</code> class</p> <pre><code>from fastauth.storage import JWTTokenStorage\n\ndef get_auth_storage():\n    return JWTTokenStorage(settings)\n</code></pre>"},{"location":"configuration/#services","title":"Services","text":"<p>After creating repositories and token storage, we need to implement AuthService class, which handle all business login such as login, token creation, etc. Inside class we can override some events, such as <code>on_after_register</code>, <code>on_after_delete</code>, etc.</p> <pre><code>from fastauth.services import BaseAuthService\nfrom fastapi import Depends\nfrom typing import Annotated\n\nclass AuthService(BaseAuthService):\n    pass\n\n\nasync def get_auth_service(\n    user_repo: UserRepoDep,\n    oauth_repo: OAuthRepoDep,\n    role_repo: RoleRepoDep,\n    token_storage: JWTTokenStorage = Depends(get_token_storage),\n):\n    return AuthService(\n        settings, user_repo, token_storage, oauth_repo=oauth_repo, role_repo=role_repo\n    )\n\n\nAuthServiceDep = Annotated[AuthService, Depends(get_auth_service)]\n</code></pre>"},{"location":"configuration/#transport","title":"Transport","text":"<p>We need choose throught which transport we get tokens from user in request, it can be Bearer in header or cookie token. To handle this we use <code>BaseTransport</code> class. For example we will use <code>CookieTransport</code> which handle token recieve throught cookies.</p> <pre><code>from fastauth.transport import CookieTransport\n\ntransport = CookieTransport(settings)\n</code></pre>"},{"location":"configuration/#fastauth","title":"FastAuth","text":"<p>Last class which Facade for everything is <code>FastAuth</code> class. It checks the validity of tokens and whether the user has access to the resource.</p> <pre><code>from fastauth import FastAuth\n\nsecurity = FastAuth(settings, get_auth_service, transport)\n</code></pre>"},{"location":"configuration/#full-sqlalchemy-example","title":"Full SQLAlchemy Example","text":"config.pymodels.pydb.pyrepositories.pyservices.pysecurity.py <pre><code>from fastauth.settings import FastAuthSettings\nfrom pydantic_settings import BaseSettingsModel\n\nclass Settings(FastAuthSettings, BaseSettingsModel):\n    DATABASE_URL: str = \"DATABASE_URL\"\n\nsettings = Settings()\n</code></pre> <pre><code>from fastauth.contrib.sqlalchemy import BaseIntRoleModel, BaseIntPermissionModel, BaseRolePermissionRel\n\nclass Permission(BaseIntPermissionModel, Base):\n    pass\n\n\nclass Role(BaseIntRoleModel[Permission], Base):\n    permisions: Mapped[Permission] = relationship(lazy='selectin')\n\n\n# Need for sqlalchemy, to indentify many-to-many table\nclass RolePermissionRel(BaseRolePermissionRel[int, int], Base):\n    pass\n\nfrom fastauth.contrib.sqlalchemy import BaseUUIDOAuthAccount\n\nclass OAuthAccount(BaseUUIDOAuthAccount):\n    pass\n\nfrom fastauth.contrib.sqlalchemy import BaseUUIDUserModel, RBACMixin, OAuthMixin\nimport uuid\n\nclass User(BaseUUIDUserModel,RBACMixin[Role], OAuthMixin[OAuthAccount], Base):\n    roles: Mapped[Role] = relationship(lazy=\"selectin\")\n    oauth_accounts: Mapped[OAuthAccount] = relationship(lazy=\"joined\")\n</code></pre> <pre><code>from .config import settings\nfrom typing import Annotated\nfrom fastapi import Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\n\nengine = create_async_engine(settings.DATABASE_URL, echo=True)\nsession_factory = async_sessionmaker(engine, expire_on_commit=False)\n\n\nasync def get_session():\n    async with session_factory() as session:\n        try:\n            yield session\n        except Exception as e:\n            await session.rollback()\n            raise e\n        finally:\n            await session.close()\n\n\nSessionDep = Annotated[AsyncSession, Depends(get_session)]\n</code></pre> <pre><code>from .db import SessionDep\nfrom .models import User, Role, Permission, OAuthAccount\nfrom fastauth.repositories import IRoleRepository, IUserRepository, IOAuthRepository\nfrom fastauth.contrib.sqlalchemy import (\n    SQLAlchemyUserRepository,\n    SQLAlchemyOAuthRepository,\n    SQLAlchemyRoleRepository,\n)\nimport uuid\n\n\n\nclass UserRepository(SQLAlchemyUserRepository[User, uuid.UUID]):\n    model = User\n\n\nclass RoleRepository(SQLAlchemyRoleRepository[Role, int]):\n    model = Role\n\n\nclass OAuthRepository(SQLAlchemyOAuthRepository[OAuthAccount, uuid.UUID, User]):\n    model = OAuthAccount\n    user_model = User\n\n\nfrom fastapi import Depends\nfrom typing import Annotated\n\nasync def get_user_repository(session: SessionDep):\n    return UserRepository(session)\n\n\nasync def get_oauth_repository(session: SessionDep):\n    return OAuthRepository(session)\n\n\nasync def get_role_repository(session: SessionDep):\n    return RoleRepository(session)\n\n\nUserRepoDep = Annotated[IUserRepository, Depends(get_user_repository)]\nOAuthRepoDep = Annotated[IOAuthRepository, Depends(get_oauth_repository)]\nRoleRepoDep = Annotated[IRoleRepository, Depends(get_role_repository)]\n</code></pre> <pre><code>from .config import settings\nfrom .repositories import UserRepoDep, OAuthRepoDep, RoleRepoDep\nfrom fastauth.storage import JWTTokenStorage\n\ndef get_auth_storage():\n    return JWTTokenStorage(settings)\n\nfrom fastauth.services import BaseAuthService\nfrom fastapi import Depends\nfrom typing import Annotated\n\nclass AuthService(BaseAuthService):\n    pass\n\n\nasync def get_auth_service(\n    user_repo: UserRepoDep,\n    oauth_repo: OAuthRepoDep,\n    role_repo: RoleRepoDep,\n    token_storage: JWTTokenStorage = Depends(get_token_storage),\n):\n    return AuthService(\n        settings, user_repo, token_storage, oauth_repo=oauth_repo, role_repo=role_repo\n    )\n\n\nAuthServiceDep = Annotated[AuthService, Depends(get_auth_service)]\n</code></pre> <pre><code>from .config import settings\nfrom .services import get_auth_service\nfrom fastauth.transport import CookieTransport\n\ntransport = CookieTransport(settings)\nsecurity = FastAuth(settings, get_auth_service, transport)\n</code></pre>"},{"location":"how_to_use/","title":"How use","text":"<p>For creating protected route, we just need call dependency for <code>FastAuth</code> class</p> <pre><code>from fastapi import FastAPI, Depends\nfrom .security import security\nfrom fastauth.schemas.auth import TokenData\n\n\napp = FastAPI()\n\n@app.get('/unprotected')\nasync def unprotected_route():\n    return {\"hello\":\"world\"}\n\n# First we check if set token, and if it`s valid, then we fetch TokenData and return it.\n\n@app.get('/protected')\nasync def protected_route(token: TokenData = Depends(security.get_access_token())):\n    return token\n</code></pre> <p>For use protection by permission we call <code>security.require_permission</code></p> <pre><code># First we check if token set, then we check if user has access to do action in resource, then return TokenData\n@app.get('/protected')\nasync def protected_route(token: TokenData = Depends(security.require_permission(\"resource:read\"))):\n    return token\n</code></pre> <p>Permission string</p> <p>To verify permission we need pass correct string in format:<code>RESOURCE:ACTION</code> Where resource and action stored in DB in acording fields</p>"},{"location":"how_to_use/#features","title":"Features","text":"<p><code>FastAuth</code> class have some methods for protection:</p> <ul> <li><code>get_access_token()</code>: Check if token set and have 'ACCESS' Type</li> <li><code>get_refresh_token()</code>: Check if token set and have 'REFRESH' Type</li> <li><code>get_current_user()</code>: Check if token is access and fetch current user from DB</li> <li><code>require_permission(permission:str)</code>: Check if user in token have provided permission</li> <li><code>require_rolr(role:str)</code>: Check if user in token have provided role</li> <li><code>require_any_permission(permissions: list[str])</code>: Check if user have at least one permission from provided</li> <li><code>require_all_permissions(permissions: list[str])</code>: Check if user have all permission from provided</li> <li><code>get_login_response(tokens: TokenResponse)</code>: Convert dataclass with tokens to FastAPI Response acording to Transport(Cookie Response, JSONResponse)</li> <li><code>get_logout_response()</code>: Return logout response</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>You can add FastAuth to your FastAPI project in a few easy steps. First of all, install dependency:</p> <p>To install default dependency over pip: <pre><code>pip install fastapi-fastauth\n</code></pre> When you install fastauth simply, you will have only authentication dependencies installed. It's highly recommended to install ORM, for RBAC and User management support. FastAuth support some popular ORM implementations, if you don't see suitable ORM, you can implement your own support, see:</p>"},{"location":"installation/#orm-support","title":"ORM Support","text":"<p>To enable ORM support(Recommended), install the following extra dependency:</p> SQLAlchemy <pre><code>pip install \"fastapi-fastauth[sqlalchemy]\"\n</code></pre>"},{"location":"installation/#oauth2-support","title":"OAuth2 Support","text":"<p>To add OAuth2 support install following extra dependency: <pre><code>pip install \"fastapi-fastauth[oauth]\"\n</code></pre></p>"},{"location":"routers/","title":"FastAuth Routers","text":"<p>FastAuth provides predefined routers with deep integration with swagger. To use it in you app, init <code>FastAuthRouter</code> class from <code>fastauth.routers</code> module with <code>FastAuth</code> instance, and then simply add it to your <code>FastAPI</code> routers.</p> <pre><code>from .dependencies import security\nfrom fastauth.routers import FastAuthRouter\nfrom fastapi import FastAPI\napp = FastAPI()\n\nauth_router = FastAuthRouter(security)\n</code></pre>"},{"location":"routers/#auth-router","title":"Auth router","text":"<p>To add such routes as <code>/auth/token/login</code>, <code>/auth/refresh</code>, <code>/auth/logout</code> user <code>get_auth_router</code> method. If you want, you can customize prefixes and routes inside FastAuthConfig ROUTER section <pre><code>app.include_router(\n    auth_router.get_auth_router(),\n    tags=[\"Auth\"]\n)\n</code></pre></p>"},{"location":"routers/#register-router","title":"Register router","text":"<p>To add <code>/auth/register</code> route, use <code>get_register_router</code> method</p> <pre><code>from .schema import UserRead, UserCreate\n\napp.include_router(\n    auth_router.get_register_router(UserRead, UserCreate),\n    tags=[\"Auth\"]\n)\n</code></pre>"},{"location":"routers/#users-router","title":"Users router","text":"<p>To add <code>/users</code> crud routers, user, <code>get_users_router</code> method</p> <pre><code>from .schema import UserRead, UserUpdate\n\napp.include_router(\n    auth_router.get_users_router(UserRead, UserUpdate),\n    tags=[\"Users\"]\n)\n</code></pre>"},{"location":"routers/#roles-router","title":"Roles router","text":"<p>By default roles router user ADMIN_DEFAULT_ROLE, USER_DEFAULT_IS_ACTIVE, USER_DEFAULT_IS_VERIFIED, but you can manually pass it for routers by <code>default_admin_role</code>, <code>is_active</code>, <code>is_verified</code> args.</p> <pre><code>from .schema import RoleRead, RoleCreate, RoleUpdate\n\napp.include_router(\n    auth_router.get_roles_router(RoleRead, RoleCreate, RoleUpdate),\n    tags=[\"Roles\"]\n)\n</code></pre>"},{"location":"routers/#permissions-router","title":"Permissions router","text":"<p>By default roles router user ADMIN_DEFAULT_ROLE, USER_DEFAULT_IS_ACTIVE, USER_DEFAULT_IS_VERIFIED, but you can manually pass it for routers by <code>default_admin_role</code>, <code>is_active</code>, <code>is_verified</code> args.</p> <pre><code>from .schema import PermissionRead, PermissionCreate, PermissionUpdate\n\napp.include_router(\n    auth_router.get_permissions_router(PermissionRead, PermissionCreate, PermissionUpdate),\n    tags=[\"Roles\"]\n)\n</code></pre>"},{"location":"routers/#verification-router","title":"Verification router","text":"<pre><code>from .schema import UserRead\n\napp.include_router(\n    auth_router.get_verify_router(UserRead),\n    tags=[\"Auth\"]\n)\n</code></pre>"},{"location":"routers/#reset-password-router","title":"Reset password router","text":"<pre><code>app.include_router(\n    auth_router.get_reset_router(),\n    tags=[\"Auth\"]\n)\n</code></pre>"},{"location":"routers/#oauth-router","title":"OAuth router","text":"<p>To get oauth router you need to setup OAuth client, and pass it to router. If you also have RBAC support, you need to set True in <code>default_role</code>, or role codename if you don`t want to use FastAuthConfig.USER_DEFAULT_ROLE</p> <pre><code>from .oauth import github_client\n\napp.include_router(\n    auth_router.get_oauth_router(github_client, default_role=True),\n    tags=[\"OAuth\"]\n)\n</code></pre>"}]}